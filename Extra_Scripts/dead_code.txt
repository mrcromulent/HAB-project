data = np.genfromtxt('telemetry_test.txt',delimiter=',',skip_header=1)


latitudes = data[:,][:,3]
longitudes = data[:,][:,4]
altitudes = data[:,][:,5]
speeds = data[:,][:,6]
headings = data[:,][:,7]



#with open('telemetry_test.csv') as csvfile:   
#    while True:   
#        for line in csvfile:
#            print(line)
#        time.sleep(1)
    
    #telem = list(csv.reader(csvfile))

#telemetry = [];

#for i in range(0,len(telem)):
#    telemetry.append(telem[i][0].split(','))


#time differences 

tdelta = datetime.strptime('11:15:49', FMT) - datetime.strptime(start_time, FMT)

# one line is about 78 characters



#WIND FIRST ATTEMPT

    FMT = '%H:%M:%S' #datetime format      
    ear_rad = 6000000 #m
    
    #find the time differences between the top and bottom of the band
    
    del_t = datetime.strptime(wind_upper_data[0], FMT) - datetime.strptime(wind_lower_data[0], FMT)
    dt = del_t.total_seconds()
    
    #Convert latitutde and longitude data to radians
    
    del_lat = (wind_upper_data[1] - wind_lower_data[1]) * math.pi / 180
    del_long = (wind_upper_data[2] - wind_lower_data[2]) * math.pi / 180

    lat_lower = wind_lower_data[1] * math.pi / 180
    lat_upper = wind_upper_data[1] * math.pi / 180
    
    #find the radius from the centre of the earth
    
    R = wind_upper_data[3] + ear_rad
    
    term_1 = (math.sin(del_lat)) ** 2
    term_2 = math.cos(lat_lower) * math.cos(lat_upper)
    term_3 = (math.sin(del_long)) ** 2
    
    dist = 2*R*math.sqrt(term_1 + term_2 * term_3)

    return [wind_lower_data[3],wind_upper_data[3],dist/dt]


BINARY THING

#convert last line into string
        
        ll = str(f.readline())
        last_line = ll[2:-6].split(',')  












x = np.linspace(0,130,predictions_made)
plt.xticks(x,times_list,rotation = 'vertical')
plt.plot(x,how_far_list)
plt.show()

            how_far_list.append(landing.how_far(prediction,time)[1])
            times_list.append(landing.how_far(prediction,time)[0])

how_far_list = []
times_list = []

import matplotlib.pyplot as plt
import numpy as np

 #   time = new_telemetry[2]
 #   lat = new_telemetry[3]
 #   long = new_telemetry[4]
 #   speed = new_telemetry[6]
 #   heading = new_telemetry[7]






###########################################################################################

#def density_at_tph(T,P,humidity):
#    
#    #from https://wahiduddin.net/calc/density_altitude.htm
#    #T in K, P in Pa, humidity as a decimal
#    
#    T_c = T - 273.2 #Find the temperature in Celsius
#    Rd = 287.05
#    eso = 6.1078
#    
#    #Define 
#    
#    c0 = 0.99999683
#    c1 = -0.90826951*10 ** (-2)
#    c2 = 0.78736169*10 ** (-4)
#    c3 = -0.61117958*10 ** (-6)
#    c4 = 0.43884187*10 ** (-8)
#    c5 = -0.29883885*10 ** (-10)
#    c6 = 0.21874425*10 ** (-12)
#    c7 = -0.17892321*10 ** (-14)
#    c8 = 0.11112018*10 ** (-16)
#    c9 = -0.30994571*10 ** (-19)
#    
#    p = (c0+T_c*(c1+T_c*(c2+T_c*(c3+T_c*(c4+\
#   T_c*(c5+T_c*(c6+T_c*(c7+T_c*(c8+T_c*c9)))))))))
#    
#    E_s = 100*eso/(p ** 8) #Pa
#    
#    pv = E_s * humidity
#    
#    return (P/(Rd*T))*(1-(0.378*pv)/P)

#def drag_at_tph(temp,press,humidity,descent_rate):
#    
#    rho = density_at_tph(temp,press,humidity)
#    
#    return 0.5 * descent_rate ** 2 * rho * (C * parachute_area + C_box * payload_area)
#    #return 0.5 * C * descent_rate ** 2 * rho * (parachute_area + payload_area)

#############################################################################################

        alt = state[3]
        
        rho = density_at_alt(alt)
        
        C = 1/(rho * v0_global ** 2 * parachute_area) * \
        (4 * (-100 - v0_global * actual_time)/(actual_time ** 2) + 2 * g_0)
#    else:
#        C_new = C * (actual_time/estimated_time)
#        
#        if not(C_new > 2 or C_new < 1):
#            C = C_new




C_payload = 1.15 #from https://www.engineersedge.com/fluid_flow/rectangular_flat_plate_drag_14036.htm
# + C_payload * payload_area)


def find_terminal_velocity(alt):
    
    rho = density_at_alt(alt)
    
    return sqrt(descent_m * g / (0.5 * C * rho * parachute_area))


def check_speed(speed):
    """This function checks the value of speed to ensure it is consistent 
    with the best current estimate of payload descent velocity, v0_global."""
        
    if v0_global > 0 and abs(speed - v0_global) > 1:
        return v0_global
        
    return speed

##############################################################
        
with open("ackerman_pred.obj", "rb") as fp:
    ack_pred = pickle.load(fp)
    
how_far_ack = []
prediction_ack_no = 0

for i in range(0,len(ack_pred),20):
    prediction  = [float(ack_pred[i][3]),float(ack_pred[i][4])]
    time = ack_pred[i][2]
    ackerman_prediction = landing.how_far(time,prediction)
    how_far_ack.append(ackerman_prediction[1])
    prediction_ack_no += 1

y = np.linspace(0,130,prediction_ack_no)
x = np.linspace(0,130,predictions_made)
plt.xticks(x,times_list,rotation = 'vertical')
plt.plot(x,how_far_list)
plt.ylabel('Error in landing site prediction [km]')
plt.xlabel('Time [GMT, equivalent to AEDT - 11]')
plt.plot(y,how_far_ack)
plt.show()
a = sorted(calc_times,reverse = True)
a2 = [i for i in a if i > 0]
max_calc = a2[0]
av_calc = sum(a2)/len(a2)
###############################################################